---
title: Go å¾®æœåŠ¡æ¶æ„å®è·µ
description: ä»é›¶æ„å»ºGoå¾®æœåŠ¡ï¼ŒåŒ…æ‹¬APIè®¾è®¡ã€æ•°æ®åº“æ“ä½œã€JWTè®¤è¯ã€WebSocketå®æ—¶é€šä¿¡ç­‰å®Œæ•´å®ç°
date: 2025-10-14
category: backend
tags: [Go, Gin, GORM, WebSocket, JWT, å¾®æœåŠ¡]
author: Tech Showcase
---

# Go å¾®æœåŠ¡æ¶æ„å®è·µ

ä½¿ç”¨ Go è¯­è¨€æ„å»ºé«˜æ€§èƒ½å¾®æœåŠ¡ï¼Œæœ¬æ–‡æ¶µç›–å®Œæ•´çš„æŠ€æœ¯æ ˆå’Œæœ€ä½³å®è·µã€‚

## é¡¹ç›®æ¶æ„

```
backend-go/
â”œâ”€â”€ cmd/
â”‚   â””â”€â”€ main.go              # åº”ç”¨å…¥å£
â”œâ”€â”€ internal/
â”‚   â”œâ”€â”€ api/                 # API è·¯ç”±å’Œå¤„ç†å™¨
â”‚   â”‚   â”œâ”€â”€ handlers.go
â”‚   â”‚   â”œâ”€â”€ middleware.go
â”‚   â”‚   â””â”€â”€ auth_handler.go
â”‚   â”œâ”€â”€ database/            # æ•°æ®åº“é…ç½®
â”‚   â”‚   â””â”€â”€ database.go
â”‚   â”œâ”€â”€ models/              # æ•°æ®æ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ user.go
â”‚   â”‚   â””â”€â”€ trade.go
â”‚   â”œâ”€â”€ services/            # ä¸šåŠ¡é€»è¾‘
â”‚   â”‚   â””â”€â”€ user_service.go
â”‚   â””â”€â”€ websocket/           # WebSocket æœåŠ¡
â”‚       â”œâ”€â”€ hub.go
â”‚       â””â”€â”€ client.go
â””â”€â”€ go.mod
```

## æ ¸å¿ƒæŠ€æœ¯æ ˆ

### 1. Gin Web æ¡†æ¶

```go
package main

import (
    "github.com/gin-gonic/gin"
    "net/http"
)

func main() {
    router := gin.Default()
    
    // CORS ä¸­é—´ä»¶
    router.Use(func(c *gin.Context) {
        c.Header("Access-Control-Allow-Origin", "*")
        c.Header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
        c.Header("Access-Control-Allow-Headers", "Origin, Content-Type, Authorization")
        
        if c.Request.Method == "OPTIONS" {
            c.AbortWithStatus(204)
            return
        }
        
        c.Next()
    })
    
    // è·¯ç”±ç»„
    api := router.Group("/api")
    {
        api.GET("/health", healthCheck)
        api.POST("/users", createUser)
        api.GET("/users/:id", getUser)
    }
    
    router.Run(":8080")
}

func healthCheck(c *gin.Context) {
    c.JSON(http.StatusOK, gin.H{
        "status": "healthy",
        "version": "1.0.0",
    })
}
```

### 2. GORM æ•°æ®åº“æ“ä½œ

```go
package database

import (
    "gorm.io/driver/mysql"
    "gorm.io/gorm"
    "log"
)

var DB *gorm.DB

func Init() {
    dsn := "user:password@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&parseTime=True&loc=Local"
    
    var err error
    DB, err = gorm.Open(mysql.Open(dsn), &gorm.Config{})
    if err != nil {
        log.Fatal("Failed to connect to database:", err)
    }
    
    // è‡ªåŠ¨è¿ç§»
    DB.AutoMigrate(&User{}, &Trade{})
    
    log.Println("Database connected successfully")
}

// æ¨¡å‹å®šä¹‰
type User struct {
    gorm.Model
    Username     string `gorm:"type:varchar(100);uniqueIndex;not null"`
    Email        string `gorm:"type:varchar(100);uniqueIndex"`
    PasswordHash string `gorm:"type:varchar(255);not null"`
}
```

### 3. JWT è®¤è¯

```go
package api

import (
    "github.com/gin-gonic/gin"
    "github.com/golang-jwt/jwt/v5"
    "net/http"
    "time"
)

var jwtSecret = []byte("your-secret-key")

type Claims struct {
    UserID uint   `json:"user_id"`
    Username string `json:"username"`
    jwt.RegisteredClaims
}

// ç”Ÿæˆ JWT Token
func generateToken(userID uint, username string) (string, error) {
    claims := Claims{
        UserID:   userID,
        Username: username,
        RegisteredClaims: jwt.RegisteredClaims{
            ExpiresAt: jwt.NewNumericDate(time.Now().Add(72 * time.Hour)),
            IssuedAt:  jwt.NewNumericDate(time.Now()),
        },
    }
    
    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    return token.SignedString(jwtSecret)
}

// éªŒè¯ä¸­é—´ä»¶
func AuthMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        tokenString := c.GetHeader("Authorization")
        if tokenString == "" {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Authorization header required"})
            c.Abort()
            return
        }
        
        // è§£æ token
        claims := &Claims{}
        token, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {
            return jwtSecret, nil
        })
        
        if err != nil || !token.Valid {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid token"})
            c.Abort()
            return
        }
        
        // å°†ç”¨æˆ·ä¿¡æ¯å­˜å…¥ä¸Šä¸‹æ–‡
        c.Set("userID", claims.UserID)
        c.Set("username", claims.Username)
        c.Next()
    }
}
```

### 4. WebSocket å®æ—¶é€šä¿¡

```go
package websocket

import (
    "github.com/gorilla/websocket"
    "github.com/gin-gonic/gin"
    "net/http"
)

var upgrader = websocket.Upgrader{
    CheckOrigin: func(r *http.Request) bool {
        return true
    },
}

type Hub struct {
    clients    map[*Client]bool
    broadcast  chan []byte
    register   chan *Client
    unregister chan *Client
}

type Client struct {
    hub  *Hub
    conn *websocket.Conn
    send chan []byte
}

func NewHub() *Hub {
    return &Hub{
        broadcast:  make(chan []byte),
        register:   make(chan *Client),
        unregister: make(chan *Client),
        clients:    make(map[*Client]bool),
    }
}

func (h *Hub) Run() {
    for {
        select {
        case client := <-h.register:
            h.clients[client] = true
        case client := <-h.unregister:
            if _, ok := h.clients[client]; ok {
                delete(h.clients, client)
                close(client.send)
            }
        case message := <-h.broadcast:
            for client := range h.clients {
                select {
                case client.send <- message:
                default:
                    close(client.send)
                    delete(h.clients, client)
                }
            }
        }
    }
}

func (h *Hub) HandleWebSocket(c *gin.Context) {
    conn, err := upgrader.Upgrade(c.Writer, c.Request, nil)
    if err != nil {
        return
    }
    
    client := &Client{hub: h, conn: conn, send: make(chan []byte, 256)}
    client.hub.register <- client
    
    go client.writePump()
    go client.readPump()
}
```

## æœ€ä½³å®è·µ

### 1. é”™è¯¯å¤„ç†

```go
type APIError struct {
    Code    int    `json:"code"`
    Message string `json:"message"`
}

func handleError(c *gin.Context, code int, message string) {
    c.JSON(code, APIError{
        Code:    code,
        Message: message,
    })
}
```

### 2. æ—¥å¿—è®°å½•

```go
import "log"

func logRequest(c *gin.Context) {
    log.Printf("[%s] %s - %s", c.Request.Method, c.Request.URL.Path, c.ClientIP())
}
```

### 3. ç¯å¢ƒé…ç½®

```go
import (
    "github.com/joho/godotenv"
    "os"
)

func init() {
    godotenv.Load()
}

func getEnv(key, defaultValue string) string {
    value := os.Getenv(key)
    if value == "" {
        return defaultValue
    }
    return value
}
```

## æ€§èƒ½ä¼˜åŒ–

1. **è¿æ¥æ± é…ç½®**ï¼šä¼˜åŒ–æ•°æ®åº“è¿æ¥æ± å¤§å°
2. **å¹¶å‘æ§åˆ¶**ï¼šä½¿ç”¨ goroutine å’Œ channel è¿›è¡Œå¹¶å‘å¤„ç†
3. **ç¼“å­˜ç­–ç•¥**ï¼šä½¿ç”¨ Redis ç¼“å­˜çƒ­ç‚¹æ•°æ®
4. **é™æµä¿æŠ¤**ï¼šå®ç° rate limiting é˜²æ­¢æ»¥ç”¨

## éƒ¨ç½²å»ºè®®

```dockerfile
FROM golang:1.22-alpine AS builder
WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download
COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -o main cmd/main.go

FROM alpine:latest
WORKDIR /root/
COPY --from=builder /app/main .
EXPOSE 8080
CMD ["./main"]
```

## æ€»ç»“

Go å¾®æœåŠ¡æ¶æ„æä¾›ï¼š

- âš¡ é«˜æ€§èƒ½å¹¶å‘å¤„ç†
- ğŸ”’ ç±»å‹å®‰å…¨å’Œç¼–è¯‘æ£€æŸ¥
- ğŸ“¦ ç®€æ´çš„ä¾èµ–ç®¡ç†
- ğŸš€ å¿«é€Ÿçš„ç¼–è¯‘å’Œéƒ¨ç½²
- ğŸ’ª å¼ºå¤§çš„æ ‡å‡†åº“æ”¯æŒ

æŒæ¡è¿™äº›æŠ€æœ¯ï¼Œä½ å°±èƒ½æ„å»ºç”Ÿäº§çº§çš„å¾®æœåŠ¡åº”ç”¨ï¼

